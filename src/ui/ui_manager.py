import os
from typing import List, Tuple, Optional
from colorama import Fore

class UIManager:
    def __init__(self, config_manager, project_manager, translation_errors: List[str], translation_warnings: List[str]):
        self.config_manager = config_manager
        self.project_manager = project_manager
        self.translation_errors = translation_errors
        self.translation_warnings = translation_warnings

    def print_header(self, title: str):
        os.system('cls' if os.name == 'nt' else 'clear')
        print("=" * 70)
        print(f"üé® C√îNG C·ª§ D·ªäCH FILE V3 - {title.upper()} üé®".center(70))
        print("=" * 70)

    def _parse_file_selection_tokens(self, tokens: List[str], files_count: int, directory_name_for_messages: str) -> Tuple[List[int], bool]:
        """
        Parses selection tokens (like "1", "^3", "5-7", "all") into a list of 0-based indices.
        Returns a tuple: (list of 0-based indices, all_tokens_were_valid_and_processed_successfully).
        """
        selected_indices_set = set()
        all_tokens_valid_and_processed = True

        if not tokens:
            return [], True 

        for token in tokens:
            token_processed_successfully_this_iteration = False
            if token == 'all':
                selected_indices_set.update(range(files_count))
                token_processed_successfully_this_iteration = True
            elif token.startswith('^'):
                try:
                    start_num_1_based = int(token[1:])
                    if 1 <= start_num_1_based <= files_count:
                        start_idx_0_based = start_num_1_based - 1
                        selected_indices_set.update(range(start_idx_0_based, files_count))
                        token_processed_successfully_this_iteration = True
                    else:
                        print(f"‚ö†Ô∏è S·ªë b·∫Øt ƒë·∫ßu '{start_num_1_based}' cho k√Ω hi·ªáu '^' kh√¥ng h·ª£p l·ªá. Ph·∫£i n·∫±m trong kho·∫£ng 1-{files_count}.")
                except ValueError:
                    print(f"‚ö†Ô∏è ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá cho k√Ω hi·ªáu '^': {token}. Mong ƒë·ª£i d·∫°ng '^<s·ªë>'.")
            elif '-' in token:
                parts = token.split('-', 1)
                if len(parts) == 2:
                    try:
                        start_num_1_based = int(parts[0])
                        end_num_1_based = int(parts[1])
                        
                        start_idx_0_based = start_num_1_based - 1
                        end_idx_0_based = end_num_1_based - 1

                        if 0 <= start_idx_0_based < files_count and \
                           0 <= end_idx_0_based < files_count and \
                           start_idx_0_based <= end_idx_0_based:
                            selected_indices_set.update(range(start_idx_0_based, end_idx_0_based + 1))
                            token_processed_successfully_this_iteration = True
                        else:
                            if not (0 <= start_idx_0_based < files_count):
                                print(f"‚ö†Ô∏è S·ªë b·∫Øt ƒë·∫ßu '{start_num_1_based}' trong kho·∫£ng ch·ªçn '{token}' kh√¥ng h·ª£p l·ªá. Ph·∫£i n·∫±m trong kho·∫£ng 1-{files_count}.")
                            elif not (0 <= end_idx_0_based < files_count):
                                print(f"‚ö†Ô∏è S·ªë k·∫øt th√∫c '{end_num_1_based}' trong kho·∫£ng ch·ªçn '{token}' kh√¥ng h·ª£p l·ªá. Ph·∫£i n·∫±m trong kho·∫£ng 1-{files_count}.")
                            elif start_idx_0_based > end_idx_0_based:
                                print(f"‚ö†Ô∏è S·ªë b·∫Øt ƒë·∫ßu '{start_num_1_based}' ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng s·ªë k·∫øt th√∫c '{end_num_1_based}' trong kho·∫£ng ch·ªçn '{token}'.")
                            else:
                                print(f"‚ö†Ô∏è Kho·∫£ng ch·ªçn '{token}' kh√¥ng h·ª£p l·ªá. H√£y ƒë·∫£m b·∫£o c√°c s·ªë n·∫±m trong kho·∫£ng 1-{files_count} v√† s·ªë ƒë·∫ßu kh√¥ng l·ªõn h∆°n s·ªë cu·ªëi.")
                    except ValueError:
                        print(f"‚ö†Ô∏è S·ªë kh√¥ng h·ª£p l·ªá trong kho·∫£ng ch·ªçn: {token}. Mong ƒë·ª£i d·∫°ng '<s·ªë>-<s·ªë>'.")
                else:
                    print(f"‚ö†Ô∏è ƒê·ªãnh d·∫°ng kho·∫£ng ch·ªçn kh√¥ng h·ª£p l·ªá: {token}. S·ª≠ d·ª•ng d·∫°ng '<s·ªë>-<s·ªë>' (v√≠ d·ª•: 1-5).")
            else:
                try:
                    num_1_based = int(token)
                    idx_0_based = num_1_based - 1
                    if 0 <= idx_0_based < files_count:
                        selected_indices_set.add(idx_0_based)
                        token_processed_successfully_this_iteration = True
                    else:
                        print(f"‚ö†Ô∏è S·ªë th·ª© t·ª± file '{num_1_based}' kh√¥ng h·ª£p l·ªá. Ph·∫£i n·∫±m trong kho·∫£ng 1-{files_count}.")
                except ValueError:
                    print(f"‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c: '{token}'. Vui l√≤ng nh·∫≠p s·ªë, kho·∫£ng ch·ªçn (vd: 1-5), ^<s·ªë>, 'all'.")
            
            if not token_processed_successfully_this_iteration:
                all_tokens_valid_and_processed = False

        return sorted(list(selected_indices_set)), all_tokens_valid_and_processed

    def select_file_from_directory(self, directory: str) -> Optional[str]:
        self.print_header("Ch·ªçn file")
        files = self.project_manager.list_translatable_files(directory, self.translation_errors)

        if not files:
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file YAML ho·∫∑c JSON n√†o trong th∆∞ m·ª•c '{directory}'")
            print("üí° H√£y ƒë·∫∑t c√°c file YAML/JSON v√†o th∆∞ m·ª•c v√† th·ª≠ l·∫°i ho·∫∑c l√†m m·ªõi danh s√°ch.")
            input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            return []

        print(f"\nüìã C√°c file YAML/JSON c√≥ s·∫µn trong '{directory}':")
        for i, file_name_display in enumerate(files):
            print(f"  [{i+1}] {file_name_display}")

        while True:
            prompt_message = (
                f"\nüî¢ Nh·∫≠p STT file, kho·∫£ng ch·ªçn (vd: 1-3, ^4), 'all' "
                f"(ho·∫∑c 'q' ƒë·ªÉ quay l·∫°i, 'r' ƒë·ªÉ l√†m m·ªõi): "
            )
            choice = input(prompt_message).strip().lower()

            if choice == 'q':
                return []
            elif choice == 'r':
                print(f"üîÑ ƒêang l√†m m·ªõi danh s√°ch file t·ª´ '{directory}'...")
                files = self.project_manager.list_translatable_files(directory, self.translation_errors)
                if not files:
                    print(f"‚ùå Kh√¥ng t√¨m th·∫•y file YAML ho·∫∑c JSON n√†o trong '{directory}' sau khi l√†m m·ªõi.")
                    return []
                print(f"\nüìã C√°c file YAML/JSON c√≥ s·∫µn trong '{directory}':")
                for i, file_name_display_refreshed in enumerate(files):
                    print(f"  [{i+1}] {file_name_display_refreshed}")
                continue

            raw_tokens = [t.strip() for t in choice.split(',') if t.strip()]

            if not raw_tokens:
                if choice:
                    print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë, kho·∫£ng ch·ªçn, 'all', 'q', ho·∫∑c 'r'.")
                else:
                    print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")
                continue

            selected_indices, all_valid = self._parse_file_selection_tokens(raw_tokens, len(files), os.path.basename(directory))

            if not selected_indices and choice:
                if all_valid:
                     print(f"‚ÑπÔ∏è C√°c ch·ªâ s·ªë b·∫°n nh·∫≠p kh√¥ng t∆∞∆°ng ·ª©ng v·ªõi file n√†o hi·ªán c√≥ (1-{len(files)}).")
                continue

            if selected_indices:
                return [os.path.join(directory, files[i]) for i in selected_indices]

    def select_multiple_files_from_directory(self, directory: str, header_override: Optional[str] = None) -> List[str]:
        effective_header = header_override if header_override else f"Ch·ªçn nhi·ªÅu file t·ª´ '{os.path.basename(directory)}'"
        
        files = self.project_manager.list_translatable_files(directory, self.translation_errors)

        if not files:
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file YAML ho·∫∑c JSON n√†o trong th∆∞ m·ª•c '{directory}'")
            print("üí° H√£y ƒë·∫∑t c√°c file YAML/JSON v√†o th∆∞ m·ª•c v√† th·ª≠ l·∫°i ho·∫∑c l√†m m·ªõi danh s√°ch.")
            input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            return []

        print(f"\nüìã C√°c file YAML/JSON c√≥ s·∫µn trong '{directory}':")
        for i, file_name_display in enumerate(files):
            print(f"  [{i+1}] {file_name_display}")

        print("\nüí° Ch·ªçn file/nhi·ªÅu file b·∫±ng c√°ch nh·∫≠p STT (v√≠ d·ª•: 1), danh s√°ch STT (1,3,5),")
        print("   kho·∫£ng ch·ªçn (6-10), ch·ªçn t·ª´ v·ªã tr√≠ ƒë·∫øn h·∫øt (^4), ho·∫∑c 'all' ƒë·ªÉ ch·ªçn t·∫•t c·∫£.")

        while True:
            prompt_message = (
                f"\nüî¢ Nh·∫≠p l·ª±a ch·ªçn (ho·∫∑c 'q' ƒë·ªÉ quay l·∫°i, 'r' ƒë·ªÉ l√†m m·ªõi): "
            )
            choice = input(prompt_message).strip().lower()

            if choice == 'q':
                return []
            elif choice == 'r':
                print(f"üîÑ ƒêang l√†m m·ªõi danh s√°ch file t·ª´ '{directory}'...")
                files = self.project_manager.list_translatable_files(directory, self.translation_errors)
                if not files:
                    print(f"‚ùå Kh√¥ng t√¨m th·∫•y file YAML ho·∫∑c JSON n√†o trong '{directory}' sau khi l√†m m·ªõi.")
                    return []
                print(f"\nüìã C√°c file YAML/JSON c√≥ s·∫µn trong '{directory}':")
                for i, file_name_display_refreshed in enumerate(files):
                    print(f"  [{i+1}] {file_name_display_refreshed}")
                continue
            
            raw_tokens = [t.strip() for t in choice.split(',') if t.strip()]
            
            if not raw_tokens:
                if choice:
                     print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p STT, kho·∫£ng ch·ªçn, 'all', 'q', ho·∫∑c 'r'.")
                else:
                     print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")
                continue

            selected_indices, all_valid = self._parse_file_selection_tokens(raw_tokens, len(files), os.path.basename(directory))

            if not selected_indices and choice:
                if all_valid:
                    print(f"‚ÑπÔ∏è C√°c ch·ªâ s·ªë b·∫°n nh·∫≠p kh√¥ng t∆∞∆°ng ·ª©ng v·ªõi file n√†o hi·ªán c√≥ (1-{len(files)}).")
                continue
            
            if selected_indices:
                return [os.path.join(directory, files[i]) for i in selected_indices]

    def display_and_clear_messages(self):
        """Displays accumulated errors and warnings, then clears them."""
        if self.translation_warnings:
            print(f"\n--- C·∫£nh b√°o d·ªãch ({len(self.translation_warnings)} c·∫£nh b√°o) ---")
            for warning_msg in self.translation_warnings:
                print(Fore.YELLOW + warning_msg + Fore.RESET)
            self.translation_warnings.clear()
        
        if self.translation_errors:
            print(f"\n--- L·ªñI D·ªäCH ({len(self.translation_errors)} l·ªói) ---")
            for error_msg in self.translation_errors:
                print(Fore.RED + error_msg + Fore.RESET)
            self.translation_errors.clear()

    def main_menu(self, api_manager, translation_core):
        while True:
            self.print_header("Menu Ch√≠nh")
            print(" L·ª±a ch·ªçn ch·ª©c nƒÉng d·ªãch:")
            print(f"  [1] D·ªãch file t·ª´ th∆∞ m·ª•c ƒë·∫ßu v√†o m·∫∑c ƒë·ªãnh ('{os.path.basename(self.config_manager.get_input_folder())}')")
            print("  [2] D·ªãch file ho·∫∑c th∆∞ m·ª•c t·ª´ ƒë∆∞·ªùng d·∫´n t√πy ch·ªçn")
            print("-" * 70)
            print(" Qu·∫£n l√Ω & C·∫•u h√¨nh:")
            print("  [3] Xem c√°c th∆∞ m·ª•c d·ª± √°n")
            print("  [4] X√≥a th∆∞ m·ª•c d·ª± √°n")
            print("  [5] Thay ƒë·ªïi th∆∞ m·ª•c ƒë·∫ßu v√†o/ƒë·∫ßu ra m·∫∑c ƒë·ªãnh")
            print("  [6] Thay ƒë·ªïi ng√¥n ng·ªØ ƒë√≠ch")
            print("  [7] C·∫•u h√¨nh ƒëa lu·ªìng (max_workers)")
            print("  [8] C·∫•u h√¨nh l·∫°i API key(s)")
            print("  [9] C·∫•u h√¨nh rate limit & retry")
            print("  [10] T√πy ch·ªçn t√™n file ƒë·∫ßu ra (gi·ªØ t√™n g·ªëc / th√™m m√£ ng√¥n ng·ªØ)")
            print("  [0] Tho√°t ch∆∞∆°ng tr√¨nh")
            print("=" * 70)
            print(f" üë§ C·∫•u h√¨nh hi·ªán t·∫°i ({self.config_manager.config_file}):")
            lang_display = self.config_manager.get_target_lang()
            api_keys = self.config_manager.get_api_keys()
            active_key_info = f"API key ch√≠nh: {Fore.GREEN}...{api_keys[0][-4:]}{Fore.RESET}" if api_keys and api_keys[0] else f"{Fore.RED}Ch∆∞a c√≥ key{Fore.RESET}"
            filename_option_display = "Gi·ªØ nguy√™n" if self.config_manager.get_keep_original_filename() else "Th√™m m√£ ng√¥n ng·ªØ"
            print(f"    üåê Ng√¥n ng·ªØ ƒë√≠ch: {lang_display}  üßµ S·ªë lu·ªìng: {self.config_manager.get_max_workers()}  üì¶ Model: gemini-2.0-flash")
            print(f"    üîë {active_key_info} ({len(api_keys)} key(s)) üè∑Ô∏è T√™n file: {filename_option_display}")
            print(f"    üìÇ Input: '{self.config_manager.get_input_folder()}' | Output: '{self.config_manager.get_output_folder()}'")
            print("=" * 70)

            choice = input("Nh·∫≠p l·ª±a ch·ªçn c·ªßa b·∫°n: ").strip()

            if choice == "1":
                self.print_header(f"D·ªãch nhi·ªÅu file t·ª´ '{self.config_manager.get_input_folder()}'")
                file_paths = self.select_multiple_files_from_directory(self.config_manager.get_input_folder())
                if file_paths:
                    print(f"\nüìã ƒê√£ ch·ªçn {len(file_paths)} file ƒë·ªÉ d·ªãch t·ª´ '{self.config_manager.get_input_folder()}':")
                    for i, path_item in enumerate(file_paths):
                        print(f"  {i+1}. {os.path.basename(path_item)}")
                    
                    print(f"C√°c file d·ªãch (b·∫£n sao chung) s·∫Ω ƒë∆∞·ª£c l∆∞u tr·ª±c ti·∫øp v√†o: '{self.config_manager.get_output_folder()}'")

                    confirm = input("\nTi·∫øp t·ª•c d·ªãch c√°c file n√†y? (y/n): ").lower()
                    if confirm == 'y':
                        translation_core.batch_translate_files(file_paths, output_subdir_for_common_copy=None, project_manager=self.project_manager, ui_manager=self)
                        print(f"\nüèÅ Ho√†n t·∫•t d·ªãch file t·ª´ '{self.config_manager.get_input_folder()}'.")
                    else:
                        print("üö´ ƒê√£ h·ªßy d·ªãch file.")
                    input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")

            elif choice == "2":
                self.print_header("D·ªãch t·ª´ ƒë∆∞·ªùng d·∫´n t√πy ch·ªçn")
                custom_path = input("Nh·∫≠p ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß ƒë·∫øn file (YAML/JSON) ho·∫∑c th∆∞ m·ª•c ch·ª©a file: ").strip()

                if not custom_path:
                    print("‚ö†Ô∏è ƒê∆∞·ªùng d·∫´n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")
                    input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
                    continue

                if os.path.isfile(custom_path):
                    if custom_path.endswith((".yml", ".yaml", ".json")):
                        translation_core.translate_file(custom_path, output_subdirectory_name=None, project_manager=self.project_manager)
                        self.display_and_clear_messages()
                    else:
                        self.translation_errors.append("‚ùå File kh√¥ng ph·∫£i l√† file YAML/JSON h·ª£p l·ªá.")
                        self.display_and_clear_messages()
                        input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
                
                elif os.path.isdir(custom_path):
                    print(f"üîé ƒêang t√¨m c√°c file YAML/JSON trong th∆∞ m·ª•c: '{custom_path}'")
                    selected_file_paths_for_dir = self.select_multiple_files_from_directory(custom_path)

                    if selected_file_paths_for_dir:
                        original_dir_basename = os.path.basename(custom_path) if custom_path else "selected_files"
                        self.print_header(f"X√°c nh·∫≠n d·ªãch t·ª´ '{original_dir_basename}'")
                        print(f"\nüìã S·∫Ω d·ªãch {len(selected_file_paths_for_dir)} file ƒë√£ ch·ªçn t·ª´ th∆∞ m·ª•c '{original_dir_basename}'.")
                        for i, path_item in enumerate(selected_file_paths_for_dir):
                            print(f"  {i+1}. {os.path.basename(path_item)}")
                        print(f"C√°c file d·ªãch (b·∫£n sao chung) s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o: '{os.path.join(self.config_manager.get_output_folder(), original_dir_basename)}'")
                        
                        confirm_dir_translate = input("\nTi·∫øp t·ª•c? (y/n): ").lower()
                        if confirm_dir_translate == 'y':
                            print(f"\nüöÄ B·∫Øt ƒë·∫ßu d·ªãch {len(selected_file_paths_for_dir)} file t·ª´ '{original_dir_basename}'...")
                            translation_core.batch_translate_files(selected_file_paths_for_dir, output_subdir_for_common_copy=original_dir_basename, project_manager=self.project_manager, ui_manager=self)
                            print(f"\nüèÅ Ho√†n t·∫•t d·ªãch c√°c file t·ª´ th∆∞ m·ª•c '{original_dir_basename}'.")
                        else:
                            print("üö´ ƒê√£ h·ªßy d·ªãch c√°c file t·ª´ th∆∞ m·ª•c.")
                        input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")

                else:
                    self.translation_errors.append(f"‚ùå ƒê∆∞·ªùng d·∫´n kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng h·ª£p l·ªá: '{custom_path}'")
                    self.display_and_clear_messages()
                    input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")


            elif choice == "3": self.project_manager.view_projects(self)
            elif choice == "4": self.project_manager.delete_projects(self)
            elif choice == "5":
                self.print_header("C·∫•u h√¨nh th∆∞ m·ª•c m·∫∑c ƒë·ªãnh")
                print(f"Th∆∞ m·ª•c ƒë·∫ßu v√†o (input) m·∫∑c ƒë·ªãnh hi·ªán t·∫°i: {self.config_manager.get_input_folder()}")
                print(f"Th∆∞ m·ª•c ƒë·∫ßu ra (output) chung cho file d·ªãch hi·ªán t·∫°i: {self.config_manager.get_output_folder()}")
                print(f"Th∆∞ m·ª•c g·ªëc cho c√°c d·ª± √°n hi·ªán t·∫°i: {self.config_manager.get_projects_folder()} (th∆∞·ªùng l√† {os.path.join(self.config_manager.project_root, 'projects')})")

                new_input_str = input("\nTh∆∞ m·ª•c ƒë·∫ßu v√†o m·∫∑c ƒë·ªãnh M·ªöI (Enter ƒë·ªÉ gi·ªØ nguy√™n): ").strip()
                if new_input_str:
                    self.config_manager.set_input_folder(new_input_str)
                    print(f"‚úÖ Th∆∞ m·ª•c ƒë·∫ßu v√†o m·∫∑c ƒë·ªãnh ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh: {self.config_manager.get_input_folder()}")
                
                new_output_str = input("Th∆∞ m·ª•c ƒë·∫ßu ra chung M·ªöI (Enter ƒë·ªÉ gi·ªØ nguy√™n): ").strip()
                if new_output_str:
                    self.config_manager.set_output_folder(new_output_str)
                    print(f"‚úÖ Th∆∞ m·ª•c ƒë·∫ßu ra chung ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh: {self.config_manager.get_output_folder()}")
                
                print(f"\n‚úÖ ƒê√£ c·∫≠p nh·∫≠t v√† l∆∞u c·∫•u h√¨nh th∆∞ m·ª•c.")
                input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            elif choice == "6":
                self.print_header("C·∫•u h√¨nh ng√¥n ng·ªØ ƒë√≠ch")
                languages = {
                    "vi": "Ti·∫øng Vi·ªát", "en": "Ti·∫øng Anh", "zh": "Ti·∫øng Trung",
                    "ja": "Ti·∫øng Nh·∫≠t", "ko": "Ti·∫øng H√†n", "fr": "Ti·∫øng Ph√°p",
                    "de": "Ti·∫øng ƒê·ª©c", "es": "Ti·∫øng T√¢y Ban Nha", "ru": "Ti·∫øng Nga"
                }

                print("C√°c ng√¥n ng·ªØ c√≥ s·∫µn:")
                for code, name in languages.items():
                    print(f"  {code}: {name}")

                choice_lang = input(f"Ch·ªçn ng√¥n ng·ªØ ƒë√≠ch (m·∫∑c ƒë·ªãnh: {self.config_manager.get_target_lang()}): ").strip()
                if choice_lang in languages:
                    self.config_manager.set_target_lang(choice_lang)
                    print(f"‚úÖ ƒê√£ ch·ªçn ng√¥n ng·ªØ ƒë√≠ch: {languages[self.config_manager.get_target_lang()]}")
                else:
                    print(f"‚ö†Ô∏è Kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c ng√¥n ng·ªØ, s·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh: {languages[self.config_manager.get_target_lang()]}")

                input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            elif choice == "7":
                self.print_header("C·∫•u h√¨nh ƒëa lu·ªìng")
                print(f"S·ªë lu·ªìng hi·ªán t·∫°i: {self.config_manager.get_max_workers()}")

                try:
                    new_workers = input(f"Nh·∫≠p s·ªë lu·ªìng m·ªõi (1-16, m·∫∑c ƒë·ªãnh: {self.config_manager.get_max_workers()}): ").strip()
                    if new_workers:
                        new_workers = int(new_workers)
                        if 1 <= new_workers <= 16:
                            self.config_manager.set_max_workers(new_workers)
                            print(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t s·ªë lu·ªìng th√†nh: {self.config_manager.get_max_workers()}")
                        else:
                            print("‚ö†Ô∏è S·ªë lu·ªìng ph·∫£i t·ª´ 1-16, gi·ªØ nguy√™n gi√° tr·ªã hi·ªán t·∫°i.")
                    else:
                        print(f"‚úÖ Gi·ªØ nguy√™n s·ªë lu·ªìng: {self.config_manager.get_max_workers()}")
                except ValueError:
                    print("‚ö†Ô∏è Gi√° tr·ªã kh√¥ng h·ª£p l·ªá, gi·ªØ nguy√™n s·ªë lu·ªìng hi·ªán t·∫°i.")

                input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            elif choice == "8": api_manager.configure_api_interactively(self)
            elif choice == "9":
                self.print_header("C·∫•u h√¨nh Rate Limit & Retry")
                print(f"C·∫•u h√¨nh hi·ªán t·∫°i:")
                print(f"- Kho·∫£ng c√°ch t·ªëi thi·ªÉu gi·ªØa c√°c request API (gi√¢y): {self.config_manager.get_min_request_interval()}")
                print(f"- S·ªë l·∫ßn th·ª≠ l·∫°i t·ªëi ƒëa cho m·ªói chunk: {self.config_manager.get_max_retries()}")
                print(f"- H·ªá s·ªë tƒÉng th·ªùi gian ch·ªù (backoff factor): {self.config_manager.get_backoff_factor()}")

                update = input("\nB·∫°n mu·ªën c·∫≠p nh·∫≠t c·∫•u h√¨nh n√†y? (y/n): ").lower()
                if update == 'y':
                    try:
                        interval_str = input(f"Kho·∫£ng c√°ch t·ªëi thi·ªÉu m·ªõi (gi√¢y, hi·ªán t·∫°i: {self.config_manager.get_min_request_interval()}, Enter ƒë·ªÉ gi·ªØ): ").strip()
                        if interval_str: self.config_manager.set_min_request_interval(max(0.1, float(interval_str)))

                        retries_str = input(f"S·ªë l·∫ßn th·ª≠ l·∫°i t·ªëi ƒëa m·ªõi (hi·ªán t·∫°i: {self.config_manager.get_max_retries()}, Enter ƒë·ªÉ gi·ªØ): ").strip()
                        if retries_str: self.config_manager.set_max_retries(max(1, int(retries_str)))

                        factor_str = input(f"H·ªá s·ªë tƒÉng th·ªùi gian ch·ªù m·ªõi (hi·ªán t·∫°i: {self.config_manager.get_backoff_factor()}, Enter ƒë·ªÉ gi·ªØ): ").strip()
                        if factor_str: self.config_manager.set_backoff_factor(max(1.1, float(factor_str))) 

                        print("\n‚úÖ ƒê√£ c·∫≠p nh·∫≠t c·∫•u h√¨nh rate limit & retry.")
                    except ValueError:
                        print("\n‚ö†Ô∏è Gi√° tr·ªã kh√¥ng h·ª£p l·ªá, gi·ªØ nguy√™n c·∫•u h√¨nh c≈©.")
                else:
                    print("\n‚ÑπÔ∏è Kh√¥ng thay ƒë·ªïi c·∫•u h√¨nh.")
                input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            elif choice == "10":
                self.print_header("T√πy ch·ªçn t√™n file ƒë·∫ßu ra")
                current_status = "Gi·ªØ nguy√™n t√™n file g·ªëc" if self.config_manager.get_keep_original_filename() else f"Th√™m m√£ ng√¥n ng·ªØ (_{self.config_manager.get_target_lang()}) v√†o t√™n file"
                print(f"Tr·∫°ng th√°i hi·ªán t·∫°i: {current_status}")
                
                choice_filename = input(f"B·∫°n c√≥ mu·ªën gi·ªØ nguy√™n t√™n file g·ªëc khi d·ªãch kh√¥ng? (y/n, m·∫∑c ƒë·ªãnh l√† '{'y' if self.config_manager.get_keep_original_filename() else 'n'}'): ").lower()
                if choice_filename == 'y':
                    self.config_manager.set_keep_original_filename(True)
                    print("‚úÖ T√™n file ƒë·∫ßu ra s·∫Ω ƒë∆∞·ª£c gi·ªØ nguy√™n (v√≠ d·ª•: 'filename.ext').")
                elif choice_filename == 'n':
                    self.config_manager.set_keep_original_filename(False)
                    print(f"‚úÖ M√£ ng√¥n ng·ªØ '_{self.config_manager.get_target_lang()}' s·∫Ω ƒë∆∞·ª£c th√™m v√†o t√™n file ƒë·∫ßu ra (v√≠ d·ª•: 'filename_{self.config_manager.get_target_lang()}.ext').")
                else:
                    print(f"‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Gi·ªØ nguy√™n c√†i ƒë·∫∑t hi·ªán t·∫°i: {current_status}")
                    
                input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            elif choice == "0":
                os.system('cls' if os.name == 'nt' else 'clear')
                print("\nüõë ƒêang tho√°t ch∆∞∆°ng tr√¨nh v√† d·ªçn d·ªçn d·∫πp...")
                self.project_manager.cleanup_temp_folders()
                print("üëã C·∫£m ∆°n ƒë√£ s·ª≠ d·ª•ng c√¥ng c·ª• D·ªãch File!")
                return
            else:
                print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.")
                input("\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
